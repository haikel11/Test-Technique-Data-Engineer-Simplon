TEST TECHNIQUE DATA ENGINEER

=================================================================

1ER CODE

# Afficher les informations g√©n√©rales du dataset magasins
dt_magasins.info()

# Afficher un aper√ßu des valeurs uniques par colonne
dt_magasins.nunique()


¬´ J‚Äôutilise info() pour v√©rifier la qualit√© des donn√©es
et nunique() pour m‚Äôassurer de l‚Äôunicit√© des identifiants
et comprendre la structure du dataset avant la mod√©lisation.


=================================================================

2EME CODE

# Analyse du dataset produits
# Afficher les informations g√©n√©rales du dataset produits
dt_produits.info()

# Afficher des statistiques descriptives pour les colonnes num√©riques
dt_produits.describe()


¬´ J‚Äôutilise info() pour v√©rifier la qualit√© et la structure des donn√©es,
puis describe() pour analyser la coh√©rence des prix et des stocks
avant d‚Äôutiliser ces donn√©es dans les calculs. ¬ª


=================================================================

3EME CODE

# Renommage des colonnes produits
dt_produits = dt_produits.rename(columns={
    "Nom": "product_name",
    "ID R√©f√©rence produit": "product_id",
    "Prix": "price",
    "Stock": "stock"
})

# Renommage des colonnes ventes
dt_ventes = dt_ventes.rename(columns={
    "Date": "sale_date",
    "ID R√©f√©rence produit": "product_id",
    "Quantit√©": "quantity",
    "ID Magasin": "store_id"
})

# Renommage des colonnes magasins
dt_magasins = dt_magasins.rename(columns={
    "ID Magasin": "store_id",
    "Ville": "city",
    "Nombre de salari√©s": "employees"
})


¬´ J‚Äôai renomm√© les colonnes pour standardiser les noms,
√©viter les caract√®res sp√©ciaux et faciliter les jointures SQL
entre les ventes, les produits et les magasins. ¬ª


=================================================================


4EME CODE

# Conversion des types produits
dt_produits["price"] = dt_produits["price"].astype(float)
dt_produits["stock"] = dt_produits["stock"].astype(int)

# Conversion des types ventes
dt_ventes["quantity"] = dt_ventes["quantity"].astype(int)
dt_ventes["sale_date"] = pd.to_datetime(dt_ventes["sale_date"])


¬´ J‚Äôai converti les types pour √©viter les erreurs de calcul
et permettre des analyses fiables, notamment sur le chiffre d‚Äôaffaires
et l‚Äô√©volution des ventes dans le temps. ¬ª


=================================================================


5EME CODE

# Fusion des ventes avec les produits (via product_id) df_sales = dt_ventes.merge( dt_produits, on="product_id", how="left" ) 
# Fusion avec les magasins (via store_id) df_sales = df_sales.merge( dt_magasins, on="store_id", how="left" ) 
# Aper√ßu du dataset final df_sales.head()

¬´ J‚Äôai fusionn√© les ventes avec les produits et les magasins
pour obtenir une vue compl√®te de chaque transaction,
indispensable pour les analyses financi√®res et g√©ographiques. ¬ª


=================================================================


6EME CODE

# Calcul du chiffre d'affaires par ligne de vente
df_sales["revenue"] = df_sales["quantity"] * df_sales["price"]

¬´ J‚Äôai calcul√© le chiffre d‚Äôaffaires pour chaque vente
afin de disposer d‚Äôun indicateur cl√© pour toutes les analyses financi√®res. ¬ª


=================================================================


7EME CODE

# Import de la librairie Sqlite3
import sqlite3

# Connexion √† la base SQLite
conn = sqlite3.connect("sales_analysis.db")

# Cr√©ation d'un curseur pour ex√©cuter les requ√™tes SQL
cursor = conn.cursor()


Connexion √† la base de donn√©es SQLite

Une base de donn√©es SQLite a √©t√© cr√©√©e afin de stocker
les donn√©es de ventes enrichies et les r√©sultats d‚Äôanalyses.

Cette √©tape permet de passer d‚Äôun traitement purement Python
√† une exploitation des donn√©es via SQL, comme en entreprise.

Utilit√© du curseur SQLite

Le curseur est l‚Äôinterface entre Python et la base de donn√©es SQLite.
Il permet d‚Äôex√©cuter des requ√™tes SQL et de r√©cup√©rer les r√©sultats.

Sans curseur, il serait impossible d‚Äôinteragir avec la base de donn√©es.


=================================================================


8EME CODE

# Cr√©ation de la table produits
cursor.execute("""
CREATE TABLE IF NOT EXISTS products (
    product_id INTEGER PRIMARY KEY,
    product_name TEXT,
    price REAL,
    stock INTEGER
)
""")

# Cr√©ation de la table magasins
cursor.execute("""
CREATE TABLE IF NOT EXISTS stores (
    store_id INTEGER PRIMARY KEY,
    city TEXT,
    employees INTEGER
)
""")

# Cr√©ation de la table ventes
cursor.execute("""
CREATE TABLE IF NOT EXISTS sales (
    sale_id INTEGER PRIMARY KEY AUTOINCREMENT,
    sale_date TEXT,
    product_id INTEGER,
    store_id INTEGER,
    quantity INTEGER,
    revenue REAL,
    FOREIGN KEY (product_id) REFERENCES products(product_id),
    FOREIGN KEY (store_id) REFERENCES stores(store_id)
)
""")

# Sauvegarde des changements
conn.commit()



La base de donn√©es est organis√©e autour de trois tables :
- `products` : dimension produit
- `stores` : dimension magasin
- `sales` : table de faits regroupant les transactions

Cette structure relationnelle permet des analyses efficaces
sur les ventes par produit et par zone g√©ographique.

¬´ J‚Äôai s√©par√© les produits, les magasins et les ventes
pour structurer les donn√©es et faciliter les analyses SQL.


=================================================================


9EME CODE

# Insertion des donn√©es produits dans la table products
# Les donn√©es sont √©cras√©es √† chaque ex√©cution pour simplifier le workflow
dt_produits.to_sql(
    "products",
    conn,
    if_exists="replace",
    index=False
)

# Insertion des donn√©es magasins dans la table stores
dt_magasins.to_sql(
    "stores",
    conn,
    if_exists="replace",
    index=False
)

# S√©lection des colonnes n√©cessaires pour correspondre
# au sch√©ma de la table sales
df_sales_sql = df_sales[
    ["sale_date", "product_id", "store_id", "quantity", "revenue"]
]

# Insertion des ventes dans la table sales
df_sales_sql.to_sql(
    "sales",
    conn,
    if_exists="replace",
    index=False
)

### Insertion des donn√©es dans la base SQLite

Les donn√©es produits, magasins et ventes ont √©t√© ins√©r√©es
dans des tables relationnelles.

Cette √©tape permet de s√©parer le traitement des donn√©es
de leur analyse, et de r√©aliser les requ√™tes directement en SQL.



=================================================================


10EME CODE

# D√©finition de la requ√™te SQL permettant de calculer
# le chiffre d'affaires total √† partir de la table des ventes
query_total_revenue = """
SELECT SUM(revenue) AS total_revenue
FROM sales
"""

# Ex√©cution de la requ√™te SQL et r√©cup√©ration du r√©sultat
# sous forme de DataFrame pandas
total_revenue = pd.read_sql_query(query_total_revenue, conn)

# Affichage du chiffre d'affaires total
total_revenue

le code permet d'executer la requ√™te sql
le code permet de retourner le r√©sultat directement sous forme de dataframe
le code permet de faciliter l'affichage et la r√©utilisation


Le chiffre d‚Äôaffaires total correspond √† la somme des revenus
g√©n√©r√©s par l‚Äôensemble des ventes sur la p√©riode √©tudi√©e.

Ce r√©sultat fournit une vision globale de la performance
commerciale de l‚Äôentreprise.


=================================================================


11EME CODE


# Insertion des donn√©es produits dans la table products
# Les donn√©es sont √©cras√©es √† chaque ex√©cution pour simplifier le workflow
dt_produits.to_sql(
    "products",
    conn,
    if_exists="replace",
    index=False
)

# Insertion des donn√©es magasins dans la table stores
dt_magasins.to_sql(
    "stores",
    conn,
    if_exists="replace",
    index=False
)

# S√©lection des colonnes n√©cessaires pour correspondre
# au sch√©ma de la table sales
df_sales_sql = df_sales[
    ["sale_date", "product_id", "store_id", "quantity", "revenue"]
]

# Insertion des ventes dans la table sales
df_sales_sql.to_sql(
    "sales",
    conn,
    if_exists="replace",
    index=False
)


### Insertion des donn√©es dans la base SQLite

Les donn√©es produits, magasins et ventes ont √©t√© ins√©r√©es
dans des tables relationnelles.

Cette √©tape permet de s√©parer le traitement des donn√©es
de leur analyse, et de r√©aliser les requ√™tes directement en SQL.

J‚Äôutilise to_sql pour ins√©rer les donn√©es pandas
dans SQLite afin de pouvoir les analyser en SQL.


=================================================================


12EME CODE


# Requ√™te SQL permettant d'analyser les ventes par ville
# en termes de quantit√©s vendues et de chiffre d'affaires
query_sales_by_city = """
SELECT 
    st.city,
    SUM(s.quantity) AS total_quantity,
    SUM(s.revenue) AS total_revenue
FROM sales s
JOIN stores st ON s.store_id = st.store_id
GROUP BY st.city
ORDER BY total_revenue DESC
"""

# Ex√©cution de la requ√™te SQL et r√©cup√©ration des r√©sultats
# sous forme de DataFrame pandas
sales_by_city = pd.read_sql_query(query_sales_by_city, conn)

# Affichage des r√©sultats
sales_by_city


### Analyse des ventes par ville

Les r√©sultats montrent le volume de ventes et le chiffre d‚Äôaffaires
g√©n√©r√© par chaque ville.

Cette analyse permet d‚Äôidentifier les zones g√©ographiques
les plus performantes et celles n√©cessitant une attention particuli√®re.


=================================================================


13EME CODE

# Requ√™te SQL permettant d'analyser les ventes par produit
# en termes de quantit√©s vendues et de chiffre d'affaires
query_sales_by_product = """
SELECT 
    p.product_name,
    SUM(s.quantity) AS total_quantity,
    SUM(s.revenue) AS total_revenue
FROM sales s
JOIN products p ON s.product_id = p.product_id
GROUP BY p.product_name
ORDER BY total_revenue DESC
"""

# Ex√©cution de la requ√™te SQL et r√©cup√©ration des r√©sultats
# sous forme de DataFrame pandas
sales_by_product = pd.read_sql_query(query_sales_by_product, conn)

# Affichage des r√©sultats
sales_by_product

### Analyse des ventes par produit

Cette analyse met en √©vidence les produits g√©n√©rant
le plus de chiffre d‚Äôaffaires et ceux avec les plus
forts volumes de vente.

Elle permet d‚Äôidentifier les produits strat√©giques
pour l‚Äôentreprise et d‚Äôoptimiser la gestion des stocks.


=================================================================


14EME CODE


# Cr√©ation de la table pour stocker le chiffre d'affaires total
cursor.execute("""
CREATE TABLE IF NOT EXISTS analysis_total_revenue (
    analysis_date TEXT,
    total_revenue REAL
)
""")

# Cr√©ation de la table pour stocker les ventes agr√©g√©es par produit
cursor.execute("""
CREATE TABLE IF NOT EXISTS analysis_sales_by_product (
    product_name TEXT,
    total_quantity INTEGER,
    total_revenue REAL
)
""")

# Cr√©ation de la table pour stocker les ventes agr√©g√©es par ville
cursor.execute("""
CREATE TABLE IF NOT EXISTS analysis_sales_by_city (
    city TEXT,
    total_quantity INTEGER,
    total_revenue REAL
)
""")

# Validation des cr√©ations de tables
conn.commit()


### Stockage des r√©sultats d‚Äôanalyse

Des tables d√©di√©es ont √©t√© cr√©√©es pour stocker les r√©sultats
des analyses de ventes.

Cette approche permet de conserver les indicateurs calcul√©s
et de faciliter leur exploitation ult√©rieure.


=================================================================


15EME CODE

# Ajout de la date d'analyse afin de permettre
# le suivi du chiffre d'affaires dans le temps
total_revenue["analysis_date"] = pd.Timestamp.now().strftime("%Y-%m-%d")

# Insertion du r√©sultat dans la table d√©di√©e
# en conservant l'historique des analyses
total_revenue.to_sql(
    "analysis_total_revenue",
    conn,
    if_exists="append",
    index=False
)

### Historisation du chiffre d'affaires

Le chiffre d‚Äôaffaires total est d√©sormais stock√© avec une date d‚Äôanalyse.
Cette approche permet de suivre l‚Äô√©volution des performances
et de rejouer les analyses dans le temps.


=================================================================


16EME CODE

# Insertion des r√©sultats d'analyse des ventes par produit
# La table est remplac√©e √† chaque ex√©cution afin de
# conserver uniquement l'√©tat le plus r√©cent
sales_by_product.to_sql(
    "analysis_sales_by_product",
    conn,
    if_exists="replace",
    index=False
)

### Stockage des ventes par produit

Les r√©sultats de l‚Äôanalyse des ventes par produit
ont √©t√© stock√©s dans une table d√©di√©e.

Cette table permet d‚Äôacc√©der rapidement aux indicateurs
sans recalculer les agr√©gations.


=================================================================


17EME CODE


# Insertion des r√©sultats d'analyse des ventes par ville
# La table est remplac√©e √† chaque ex√©cution afin de
# conserver uniquement les indicateurs les plus r√©cents
sales_by_city.to_sql(
    "analysis_sales_by_city",
    conn,
    if_exists="replace",
    index=False
)


### Stockage des ventes par ville

Les r√©sultats de l‚Äôanalyse des ventes par ville ont √©t√©
stock√©s dans une table d√©di√©e.

Cette table permet une exploitation rapide des performances
g√©ographiques sans recalcul des agr√©gats.

üéØ R√âPONSE ORALE PARFAITE

¬´ Je stocke les ventes par ville afin de conserver
une vision g√©ographique des performances commerciales. ¬ª


=================================================================



## Conclusion

Ce projet a permis de mettre en place un pipeline simple
d‚Äôingestion, de transformation, d‚Äôanalyse et de stockage
des donn√©es de ventes.

Les donn√©es ont √©t√© structur√©es dans une base SQLite,
analys√©es via SQL, puis les r√©sultats ont √©t√© persist√©s
afin de faciliter leur exploitation.

Cette approche se rapproche d‚Äôun contexte r√©el de
Data Engineering et r√©pond aux objectifs du brief.
